<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hashcode、equals和toString]]></title>
    <url>%2F2019%2F09%2F23%2Fhashcode%E3%80%81equals%E5%92%8CtoString%2F</url>
    <content type="text"><![CDATA[参考：https://www.journaldev.com/21095/java-equals-hashcode 目录 Java equals()定义 Java hashCode()定义 ==操作符与hashCode() equals()和hashCode() 的重要性和应用 什么时候override equals和hashCode方法 equals()和hashCode()如何实现 什么是hashCollision 冲突 如果我们都不实现hashCode和equals会怎样？ 实现equals()和hashCode的最佳实践 String的equals and hashcode Integer的equals and hashcode abstractSet的equals and hashcode 总结Map/Set的key为自定义对象时，必须重写hashCode和equals。 关于hashCode和equals的处理，遵循如下规则：1） 只要重写equals，就必须重写hashCode。2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。3） 如果自定义对象做为Map的键，那么必须重写hashCode和equals。 Java equals()Object的equals默认实现方式如下 1public boolean equals(Object obj) &#123; return (this == obj);&#125; 根据java doc中equals方法的实现的规范，任何对equals的实现都必须满足一下原则： 对任一对象x，x.equals(x)应该return true0. 对任何二个对象 x、y,x.equals(y)应该return true，当前仅当 y.equals(x) return true 对于任意多个对象x、y、z,如果 x.equals(y) = true and y.equals(z) = truethen x.equals(z) = true.0. 多次调用x.equals(y)，应该返回相同结果，除非其中有对象的属性发生变化。 当两个对象的引用指针指向同一个对象时，这时equals应该返回true java hashCode()Java Object hashCode()是一个native方法，作用是返回一个对象的整数型的hash值。 它的实现需要满足以下原则⁃ 多次调用hashCode()方法应该返回相同的integer值，除非对象的属性有改动，这点和equals的原则保持一致⁃ 一个Object hash Code value可能有变化，在多次执行同样的应用时⁃ 如果两个对象equals为true，则他们的hashCode必然相等⁃ 如果两个对象equals不相等，则他们的hashCode未必不等 ==操作符与hashCode() java使用==操作符，对于对象，来判断2个对象的堆内存地址是否相等，对于非对象，==则比较的是基本数据类型的值 一般情况下，equals会优先判断内存地址是否相等 对于String有常量池优化，对于Integer范围在-127到128也有常量池优化 importance of equals() and HashCode() methodJava hashCode() and equals() method在基于Hash table的数据结构和对象中，被广泛用于获取数据和存储数据。具体看看：How HashMap works in java? 注意: 如果你不把class作为Hash Table的key，而是使用默认的实现时，当你的equals()和hashCode()发生冲突时，你的程序是不会抛出任何异常，也不会产生任何问题但是如果你打算使用一个类作为例如hashMap、Set等基于hash table的key时，那你必须重写hashCode() 方法下面举例说明hashCode默认实现和自定义实现对于hash table的区别定义一个DataKey的class 123456package com.journaldev.java;public class DataKey &#123;private String name;private int id; // getter and setter methods@Overridepublic String toString() &#123;return "DataKey [name=" + name + ", id=" + id + "]";&#125;&#125; 这里是默认的实现 123456789101112131415161718192021222324package com.journaldev.java;import java.util.HashMap;import java.util.Map;public class HashingTest &#123;public static void main(String[] args) &#123; Map&lt;DataKey, Integer&gt; hm = getAllData(); DataKey dk = new DataKey(); dk.setId(1); dk.setName("Pankaj"); System.out.println(dk.hashCode()); Integer value = hm.get(dk); System.out.println(value);&#125;private static Map&lt;DataKey, Integer&gt; getAllData() &#123; Map&lt;DataKey, Integer&gt;hm = new HashMap&lt;&gt;(); DataKey dk = new DataKey(); dk.setId(1); dk.setName("Pankaj"); System.out.println(dk.hashCode()); hm.put(dk, 10); return hm;&#125;&#125; 运行结果会打印null。这是因为对象的hashCode() method被用来查找bucket，进而寻找到对应的key。由于我们没有获取hashMap 的 keys的权限，于是我们创建了一个新的对象，导致这2个对象的hash code值不一样，因此hash value就无法找到。 Implementing equals() and hashCode() method我们可以定义自己的equals和hashCode方法的实现，但是如果我们实现出错，那么会导致很多奇怪的运行时异常，辛运的是大部分idea提供了各种方式去自动化的实现equals和hashcode方法，并且我们也可以根据需求改变他们。如下是自动生成的hashcode和equals的实现 12345678910111213141516171819202122@Overridepublic int hashCode() &#123;final int prime = 31;int result = 1;result = prime * result + id;result = prime * result + ((name == null) ? 0 : name.hashCode());return result;&#125;@Overridepublic boolean equals(Object obj) &#123; if (this == obj)return true; if (obj == null)return false; if (getClass() != obj.getClass())return false;DataKey other = (DataKey) obj;if (id != other.id)return false;if (name == null) &#123; if (other.name != null)return false; &#125;else if (!name.equals(other.name)) return false; return true;&#125; 注意：计算hashcode和判断equals时，使用相同的字段，这样就能保证一致 我们也可以使用 Project Lombok 自动化生成 What is Hash Collision 通常情况下，hash的get和put的逻辑如下 首先，定义Bucket 如果没有object在bucket中以相同的hash code出现，则使用put操作时会添加元素，使用get操作时会返回null 如果有任何object在bucket中以同样的hash code出现，则再判断key的equals方法 3.1 如果equals return true，且是put，则value被替换 3.2 如果equals return false，且是put，则新的entry会被添加到bucket中 3.3 如果equals return true 且是get。则返回value 3.4 如果equals return false，则返回null 2个key具有相同的hashcode被称为hash冲突，如果hashcode方法没有合理的实现，那么就会就会有很大的几率发生hash冲突，导致map的entries没能均匀的散列，导致get和put的性能问题，这个点是需要在生成hashCode时最先考虑的 What if we don’t implement both hashCode() and equals()?我们已经看到了如果我们不实现hashcode，那么hashMap就无法找到entry。如果我们只实现hashcode不实现equals，导致equals返回false，那么也同样无法获取到值 Best Practices for implementing equals() and hashCode() method 使用相同的对象属性计算hashcode和equals方法，保证这2者的一致性原则 最好使用不可变对象作为map或set的key，这样我们就能避免很多不必要的重写，这就是为什么String经常作为hash的key的原因 在实现hashcode的时候，一定要保证hash值是均匀分布在整个buckets中的 String equals and hashcode 先比较内存地址，如果相等直接return true 再比较 class类描述 -&gt; 然后对String字符数组中的每个字符比较 String重写了equals,只需要值相等就可以return true123456789101112131415161718192021222324252627282930313233343536 public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125;``` - ```javapublic int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125; Integer的equals and hashcode/** * Returns a hash code for a {@code int} value; compatible with * {@code Integer.hashCode()}. * * @param value the value to hash * @since 1.8 * * @return a hash code value for a {@code int} value. */ public static int hashCode(int value) { return value; } /** * Compares this object to the specified object. The result is * {@code true} if and only if the argument is not * {@code null} and is an {@code Integer} object that * contains the same {@code int} value as this object. * * @param obj the object to compare with. * @return {@code true} if the objects are the same; * {@code false} otherwise. */ public boolean equals(Object obj) { if (obj instanceof Integer) { return value == ((Integer)obj).intValue(); } return false; } abstractSet的equals and hashcodepublic boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Set)) return false; Collection&lt;?&gt; c = (Collection&lt;?&gt;) o; if (c.size() != size()) return false; try { return containsAll(c); } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } } public int hashCode() { int h = 0; Iterator&lt;E&gt; i = iterator(); while (i.hasNext()) { E obj = i.next(); if (obj != null) h += obj.hashCode(); } return h; } 附录 这篇文章简单讲了一下为什么使用31作为hash的乘积来计算hashcode 关于hashcode 里面 使用31 系数的问题]]></content>
      <tags>
        <tag>hashcode,equals和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客开通了]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A%E4%BA%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[article title]]></title>
    <url>%2F2019%2F09%2F23%2Farticle-title%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
